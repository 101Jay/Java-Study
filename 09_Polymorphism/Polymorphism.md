## 다형성(Polymorphism)
- 하나의 인스턴스가 여러 가지 타입을 가질 수 있는 것을 의미한다.
- 다형성은 객체지향 프로그래밍의 3대 특징(`캡슐화, 상속, 다형성`) 중 하나
- 다형성은 상속을 기반으로 한 기술

### 다형성의 장점
- 여러 타입의 객체를 하나의 타입으로 관리할 수 있으므로 `유지보수성`과 `생산성`이 증가됨
- 확장성이 좋은 코드 작성 가능
- 결합도를 낮춰 유지보수성 증가

### 동적바인딩
- 컴파일 당시에는 해당 타입의 메소드와 연결되어 있다가, 런타임 당시 실제 객체가 가진 오버라이딩된 메소드로 바인딩이 바뀌어 동작하는 것을 의미
```java
Car car = new Sonata();
car.move();
```
- 컴파일 당시에는 Car의 move 메소드에 바인딩되어 있지만, 런타임 시점에는 Car에 할당된 실제 객체 Sonata의 move 메소드로 바인딩 됨
- 처음에는 Car 객체의 실행 코드와 연결되어 있다가, 런타임 시에는 Sonata의 실행코드와 연결됨
- 동적바인딩이 이루어지기 위해서는 메소드 오버라이딩이 선행되어 있어야 함

### 클래스의 형변환 
- 업캐스팅 / 다운캐스팅 
#### 업캐스팅 : 상위 타입으로의 형변환
- 묵시적으로 이루어지며, 코드 구현시 형변환을 생략해도 자동으로 이루어진다. 
#### 다운캐스팅 : 하위 타입으로의 형변환 
- 반드시 명시적으로 형변환을 진행해줘야 한다.

```java
Car car = new Sonata(); // (Car) new Sonata(); 의 형태로 묵시적 업캐스팅이 이루어진다.
```
- 이 때 Car 객체가 가지고 있는 메소드를 사용하는 건 문제가 되지 않지만, Sonata만이 가지고 있는 메소드를 사용하고자 하면, 명시적 다운캐스팅을 진행해줘야 한다.
```java
((Sonata) car).moveSonata(); // car 인스턴스를 Sonata로 형변환한 뒤, Sonata만이 가지고 있는 moveSonata(); 메소드를 사용
```

### instanceof 연산자
- 참조형 변수를 대상으로 해당 클래스 타입의 객체 주소를 참조하고 있는지 확인하기 위해 사용 
- 결과값은 true or false
- 형 변환을 잘못할 경우 예외가 발생하기 때문에 instanceof 연산자를 통해 해당 형으로 변환이 가능한지 미리 확인하고 형변환을 진행하는 것이 좋다.
```java
Car car = new Sonata();
car instanceof Sonata;
```

### 매개변수에 쓰이는 다형성
- 묵시적 형변환을 이용해서 부모클래스의 자료형으로 매개변수를 선언해두면, 메소드 사용시에 자식클래스의 자료형을 매개변수로 넘겨서 사용할 수 있다. 
- 동일한 메시지를 수신해서 서로 다르게 응답할 수 있는 방식으로서 다형성이 사용되는 케이스이다.
```java
public void eat(Animal animal){
    animal.eat();
}

Animal animal1 = new Animal();
Rabbit animal2 = new Rabbit(); // Rabbit 객체는 Animal 객체를 상속 받은 객체

animal1.eat(animal2); // Rabbit 객체로 선언되었지만, 묵시적 형변환을 활용해 Animal 객체를 매개변수로 받는 메서드에 매개변수로 활용됨.
```

### 리턴 타입에 쓰이는 다형성
- 메서드의 리턴 타입을 부모클래스로 선언해둬, 다양한 자식클래스의 자료형을 리턴할 수 있도록 함
```java
public Car randomCar(){
	int random = (int) (Math.random() * 2);
	return random == 0? new Sonata() : new Avante();
}
```
- 이렇게 활용하면, 클래스를 활용하는 측과의 결합도가 낮아진다. 
- 즉, 차의 이름이 바뀌어도 randomCar의 리턴 값만 메소드 내부적으로 바꿔주면 사용자 측에서는 수정 없이 사용이 가능하다.

---

### 추상클래스
- 미완성 클래스로, 추상클래스로는 인스턴스를 생성할 수 없다.
- 추상클래스를 사용하기 위해서는 해당 추상클래스를 상속 받은 하위 클래스를 이용해야 한다. 이 때도 다형성이 활용된다.
- 추상클래스의 추상메서드는 오버라이딩에 대한 강제성이 부여됨
  - 즉, 하위 클래스를 이용하여 해당 추상클래스를 상속 받을 때, 그 안에 존재하는 추상메서드를 오버라이딩 하지 않으면 컴파일 에러가 발생함

### 인터페이스
- 추상메소드와 상수 필드(`public static final`)만 가질 수 있는 클래스의 변형
  - 상수 필드만 작성이 가능하기 때문에, `int MIN_NUM`이라고 변수를 선언해도, 묵시적으로 `public static final`을 앞에 붙여서 인식한다. 따라서 바로 초기화를 해줘야 한다.
- 사용 목적
  1. 추상클래스와 비슷하게 필요한 기능을 공통화해서 강제성을 부여할 목적(표준화)
  2. 단일 상속만을 지원하는 자바의 단점 극복(다중 상속)
     - 인터페이스를 활용하면 여러 타입을 동시에 상속 받을 수 있다.
- implements 키워드를 활용하여 상속 받음
- 인터페이스는 생성자를 갖지 않는다. 따라서 직접 인스턴스를 생성할 수 없으며, 레퍼런스 타입으로만 이용이 가능하다.
```java
InterfaceProduct interfaceProduct = new Product();
```

