## 다형성(Polymorphism)
- 하나의 인스턴스가 여러 가지 타입을 가질 수 있는 것을 의미한다.
- 다형성은 객체지향 프로그래밍의 3대 특징(`캡슐화, 상속, 다형성`) 중 하나
- 다형성은 상속을 기반으로 한 기술

### 다형성의 장점
- 여러 타입의 객체를 하나의 타입으로 관리할 수 있으므로 `유지보수성`과 `생산성`이 증가됨
- 확장성이 좋은 코드 작성 가능
- 결합도를 낮춰 유지보수성 증가

### 동적바인딩
- 컴파일 당시에는 해당 타입의 메소드와 연결되어 있다가, 런타임 당시 실제 객체가 가진 오버라이딩된 메소드로 바인딩이 바뀌어 동작하는 것을 의미
```java
Car car = new Sonata();
car.move();
```
- 컴파일 당시에는 Car의 move 메소드에 바인딩되어 있지만, 런타임 시점에는 Car에 할당된 실제 객체 Sonata의 move 메소드로 바인딩 됨
- 처음에는 Car 객체의 실행 코드와 연결되어 있다가, 런타임 시에는 Sonata의 실행코드와 연결됨
- 동적바인딩이 이루어지기 위해서는 메소드 오버라이딩이 선행되어 있어야 함

### 클래스의 형변환 
- 업캐스팅 / 다운캐스팅 
#### 업캐스팅 : 상위 타입으로의 형변환
- 묵시적으로 이루어지며, 코드 구현시 형변환을 생략해도 자동으로 이루어진다. 
#### 다운캐스팅 : 하위 타입으로의 형변환 
- 반드시 명시적으로 형변환을 진행해줘야 한다.

```java
Car car = new Sonata(); // (Car) new Sonata(); 의 형태로 묵시적 업캐스팅이 이루어진다.
```
- 이 때 Car 객체가 가지고 있는 메소드를 사용하는 건 문제가 되지 않지만, Sonata만이 가지고 있는 메소드를 사용하고자 하면, 명시적 다운캐스팅을 진행해줘야 한다.
```java
((Sonata) car).moveSonata(); // car 인스턴스를 Sonata로 형변환한 뒤, Sonata만이 가지고 있는 moveSonata(); 메소드를 사용
```

### instanceof 연산자
- 참조형 변수를 대상으로 해당 클래스 타입의 객체 주소를 참조하고 있는지 확인하기 위해 사용 
- 결과값은 true or false
```java
Car car = new Sonata();
car instanceof Sonata;
```

### 매개변수에 쓰이는 다형성
- 묵시적 형변환을 이용해서 부모클래스의 자료형으로 매개변수를 선언해두면, 메소드 사용시에 자식클래스의 자료형을 매개변수로 넘겨서 사용할 수 있다. 
- 동일한 메시지를 수신해서 서로 다르게 응답할 수 있는 방식으로서 다형성이 사용되는 케이스이다.
```java
public void eat(Animal animal){
    animal.eat();
}

Animal animal1 = new Animal();
Rabbit animal2 = new Rabbit(); // Rabbit 객체는 Animal 객체를 상속 받은 객체

animal1.eat(animal2); // Rabbit 객체로 선언되었지만, 묵시적 형변환을 활용해 Animal 객체를 매개변수로 받는 메서드에 매개변수로 활용됨.
```

### 리턴 타입에 쓰이는 다형성
- 메서드의 리턴 타입을 부모클래스로 선언해둬, 다양한 자식클래스의 자료형을 리턴할 수 있도록 함
```java
public Car randomCar(){
	int random = (int) (Math.random() * 2);
	return random == 0? new Sonata() : new Avante();
}
```
- 이렇게 활용하면, 클래스를 활용하는 측과의 결합도가 낮아진다. 
- 즉, 차의 이름이 바뀌어도 randomCar의 리턴 값만 메소드 내부적으로 바꿔주면 사용자 측에서는 수정 없이 사용이 가능하다.