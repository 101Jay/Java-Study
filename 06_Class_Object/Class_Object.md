## 클래스와 객체
### 클래스 == 자료형
- 서로 다른 자료형의 데이터들을 사용자 정의로 하나로 묶어 새로운 타입을 정의한 것
- 속성들을 하나로 묶어 새로운 자료형으로 만들어 놓은 것이 클래스
- 클래스의 필드(속성)에 접근하기 위해 참조 연산자 `.`을 활용한다.
- 클래스를 ram에 올리기 위해서는 선언해줘야 함
- 클래스 내부에서 선언하는 변수를 `전역변수` == `필드` == `인스턴스 변수` == `속성` 이라고 한다.

```java
public class Application{
    public static void main(String[] args){
        Member member = new Member(); // 선언과 동시에 할당
        member.name = "홍길동";
    }
}
```
- 선언된 참조 변수 member는 stack에 쌓이고, new로 할당된 공간을 객체(== 인스턴스)라고 부름
- 참조 변수 member에는 해당 인스턴스의 시작 위치 주소값을 저장해준다.

### 객체
- 우리가 인지할 수 있는 모든 것을 `객체`라고 한다.
- 프로그램이란, 현실 세계의 문제를 해결하기 위해 존재하며, 현실 세계의 모든 문제들은 객체와 객체간의 상호작용에 의해 발생한다.
- 여기서는 실제로 클래스가 할당된 것을 의미한다.

### 왜, 클래스와 객체를 사용할까?
- 자료형이 다른 여러 속성들은 자료형이 다르기 때문에 배열로 만들 수가 없다. 그럴 때 객체를 활용한다.
- 다른 메서드에 여러 자료들을 한 번에 전달하거나 return 받기 위함이다.

### 클래스 vs 객체
- 클래스는 코드로 되어 있는 코드상의 존재일 뿐이고, 이를 실제로 공간을 할당하고 만들어 낸 것이 객체이다.

---
클래스의 필드에 접근하기 위해서는 참조 연산자를 사용한다고 했다. 이렇게 직접 접근할 때 생기는 문제는 없을까?
### 클래스의 필드에 직접 접근할 때 발생하는 문제
#### 1. 잘못된 값을 대입할 수 있다.
#### 2. 클래스 내부의 필드명이 변경되면 클래스를 참조하고 있는 다른 모든 코드들을 수정해야 한다. 유지보수성이 매우 떨어진다.

- 이를 해결하기 위해 `캡슐화`의 개념을 활용해보자.

### 캡슐화란? 
- 결합도를 낮추기 위해 필드에 대한 직접 접근을 제한하고, public 메소드를 이용해서 간접적으로 접근하여 사용할 수 있도록 하는 것

#### 접근제한자(modifiers)란?
- public, protected, default, private로 구성되어 있으며, 말 그대로 접근 허용 범위를 나타낸다.

  |  | 해당 클래스  | 동일 패키지 | 후손 패키지 | 전체 |
  | --- | --- | --- | --- | --- |
  | public ( + ) | o | o | o | o |
  | protected (#) | o | o | o |  |
  | (default) (~) | o | o |  |  |
  | private (-) | o |  |  |  |

- 클래스 수준에서는, public과 default만 사용 가능하다.(이외에는 Java에서 못 만들게 하고 있다.)
- 필드 자체는 private로 해당 클래스에서만 접근할 수 있도록 만들고, 이를 활용할 수 있는 메소드를 public으로 만들어서 사용하면 된다.
- 이를 활용한 것이 getter와 setter 
- 그러나, getter와 setter의 경우 여전히 메소드 이름에 변수명이 들어가 있다는 한계가 존재한다.

#### `은닉`의 개념
- 결합도를 낮춰 유지보수를 용이하게 하기 위해 사용하는 개념
- 데이터 은닉 : 캡슐화(외부에서 데이터를 접근하지 못하도록 하는 것)
- 타입 은닉 : 다형성을 활용해 타입 결합도를 낮추는 것
- 구현 은닉 : 외부에서 직접 할당하는 것을 막아 결합도를 낮추는 것